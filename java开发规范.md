## 维创盈通Java开发规范(试用版)

### svn协作规范

#### 先更新，再提交
SVN更新的原则是要随时更新，随时提交。当完成了一个小功能，能够通过编译并且自己测试之后，谨慎地提交。 
如果在修改的期间别人也更改了svn的对应文件，那么commit就可能会失败。如果别人和自 己更改的是同一个文件，那么update时会自动进行合并，如果修改的是同一行，那么合并时会产生冲突，这种情况就需要同之前的开发人员联系，两个人一起协商解决冲突，解决冲突之后，需要两人一起测试保证解决冲突之后，程序不会影响其他功能。 
在更新时注意所更新文件的列表，如果提交过程中产生了更新，则也是需要重新编译并且完成自己的一些必要测试，再进行提交。这样既能了解别人修改了哪些文件，同时也能避免SVN合并错误导致代码有错。

#### 多提交
每次提交的间歇尽可能地短，以几个小时的开发工作为宜。例如在更改UI界面的时候，可以每完成一个UI界面的修改或者设计，就提交一次。在开发功能模块的时候，可以每完成一个小细节功能的测试，就提交一次，在修改bug的时候，每修改掉一个bug并且确认修改了这个bug，也就提交一次。我们提倡多提交，也就能多为代码添加上保险。

#### 不要提交不能通过编译的代码
代码在提交之前，首先要确认自己能够在本地编译。如果在代码中使用了第三方类库，要考虑到项目组成员中有些成员可能没有安装相应的第三方类库。项目经理在准备项目工作区域的时候，需要考虑到这样的情况，确保开发小组成员在签出代码之后能够在统一的环境中进行编译。

#### 每次提交必须书写明晰的标注
在一个项目组中使用SVN，如果提交空的标注或者不确切的标注将会让项目组中其他的成员感到很无奈，项目经理无法很清晰的掌握工作进度，无法清晰的把握此次提交的概要信息。在发现错误后也无法准确的定位引起错误的文件。所以，在提交工作时，要填写明晰的标注，能够概要的描述所提交文件的信息，让项目组其他成员在看到标注后不用详细看代码就能了解你所做的修改。

#### 提交时注意不要提交本地自动生成的文件
例如eclipse中的.classpath文件，Windows生成的缩略图Thumbs.db，项目编译生成的临时文件.obj, .class等等。如果项目中没有进行这方面的配置来强行禁止提交这样的文件，请自觉不要提交这样的文件。提交了这样的文件后，别人在更新后就可能与本地的环境冲突从而影响大家的工作。

### Java编码规范

#### 命名
1. 所有编程相关命名均不能以下划线或美元符号开始,也不能以下划线或美元符号结束。
2. 所有编程相关的命名严禁使用拼音与英文混合的方式。正确的英文拼写和语法可以让阅读者易于理解,避免歧义。注意,即使纯拼音命名方式 也要避免采用。
3. 类名使用 UpperCamelCase 风格,必须遵从驼峰形式,但以下情形例外:(领域模型 的相关命名)DO / DTO / VO / DAO 等。
4. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格,必须遵从 驼峰形式。
5. 常量命名全部大写,单词间用下划线隔开,力求语义表达完整清楚,不要嫌名字长。
6. 抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类命 名以它要测试的类的名称开始,以 Test 结尾
7. 中括号是数组类型的一部分,数组定义如下:String[] args;请勿使用 String args[]的方式来定义
8. POJO 类中的任何布尔类型的变量,都不要加 is,否则部分框架解析会引起序列化错 误。
9. 包名统一使用小写,点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用
单数形式,但是类名如果有复数含义,类名可以使用复数形式。
10. 杜绝完全不规范的缩写,避免望文不知义。
11. 接口类中的方法和属性不要加任何修饰符号(public 也不要加),保持代码的简洁 性,并加上有效的 javadoc 注释。尽量不要在接口里定义变量,如果一定要定义变量,肯定是 与接口方法相关,并且是整个应用的基础常量。

#### 常量
1. 不允许出现任何魔法值(即未经定义的常量)直接出现在代码中。
2. long 或者 Long 初始赋值时,必须使用大写的 L,不能是小写的 l,小写容易跟数字 1 混淆,造成误解。
3. 不要使用一个常量类维护所有常量,应该按常量功能进行归类,分开维护。如:缓存 相关的常量放在类:CacheConsts 下;系统配置相关的常量放在类:ConfigConsts 下。

#### 格式
1. 大括号的使用约定。如果是大括号内为空,则简洁地写成{}即可,不需要换行;如果 是非空代码块则:
        1) 左大括号前不换行。 
        2) 左大括号后换行。 
        3) 右大括号前换行。
        4) 右大括号后还有 else 等代码则不换行;表示终止右大括号后必须换行。
2. 左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也不出现空 格。
3. if/for/while/switch/do 等保留字与左右括号之间都必须加空格。
4. 任何运算符左右必须加一个空格。
5. 代码块缩进 4 个空格,如果使用 tab 缩进,请设置成 1 个 tab 为 4 个空格。
6. 单行字符数限制不超过 120 个
7. 方法参数在定义和传入时,多个参数逗号后边必须加空格。
8. IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式,不
要使用 windows 格式。
9. 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之 间插入一个空行。相同业务逻辑和语义之间不需要插入空行。
10. 不允许多个语句放到一行中，一行只写一条语句
11. 顺序实现流程的说明使用1，2，3，4在每个实现步骤部分的代码前进行注释

#### 面向对象
1. 避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成 本,直接用类名来访问即可。
2. 所有的覆写方法,必须加@Override 注解。
3. 相同参数类型,相同业务含义,才可以使用 Java 的可变参数,避免使用 Object。 说明:可变参数必须放置在参数列表的最后。
4. 对外暴露的接口签名,原则上不允许修改方法签名,避免对接口调用方产生影响。接 口过时必须加@Deprecated 注解,并清晰地说明采用的新接口或者新服务是什么。
5. 不能使用过时的类或方法。
6. Object的equals方法容易抛空指针异常,应使用常量或确定有值的对象来调用equals。
7. 所有的相同类型的包装类对象之间值的比较,全部使用 equals 方法比较。
8. 关于基本数据类型与包装数据类型的使用标准如下:
    1) 所有的 POJO 类属性必须使用包装数据类型。
    2) 所有的局部变量推荐使用基本数据类型。
9. 序列化类新增属性时,请不要修改 serialVersionUID 字段,避免反序列失败;如果 完全不兼容升级,避免反序列化混乱,那么请修改 serialVersionUID 值。
10. 构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中。
11. POJO 类必须写 toString 方法。在方法执行抛出异常时,可以直接调用 POJO 的 toString()方法打印其属性值,便于排 查问题。
12. 使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内 容的检查,否则会有抛 IndexOutOfBoundsException 的风险。
13. 循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。
14. 类成员与方法访问控制从严

#### 集合
1. Map/Set 的 key 为自定义对象时,必须重写 hashCode 和 equals。
2. ArrayList 的 subList 结果不可强转成 ArrayList,否则会抛出 ClassCastException 异常:java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;subList 返回的是 ArrayList 的内部类 SubList,并不是 ArrayList ,而是 ArrayList 的一个视图,对于 SubList 子列表的所有操作最终会反映到原列表上。
3. 在 subList 场景中,高度注意对原集合元素个数的修改,会导致子列表的遍历、增加、
删除均产生 ConcurrentModificationException 异常。
4. 使用集合转数组的方法,必须使用集合的 toArray(T[] array),传入的是类型完全 一样的数组,大小就是 list.size()。
5. 使用工具类Arrays.asList()把数组转换成集合时,不能使用其修改集合相关的方法, 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。
6. 泛型通配符<? extends T>来接收返回的数据,此写法的泛型集合不能使用 add 方法。
7. 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式,如果并发操作,需要对 Iterator 对象加锁。
8. 在 JDK7 版本以上,Comparator 要满足自反性,传递性,对称性,不然 Arrays.sort, Collections.sort 会报 IllegalArgumentException 异常。
9. 集合初始化时,尽量指定集合初始值大小。
10. 使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历。
说明:keySet 其实是遍历了 2 次,一次是转为 Iterator 对象,另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中,效率更 高。如果是 JDK8,使用 Map.foreach 方法。

#### 并发
1. 获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。
2. 线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。
3. SimpleDateFormat 是线程不安全的类,一般不要定义为 static 变量,如果定义为 static,必须加锁,或者使用 DateUtils 工具类。如果是 JDK8 的应用,可以使用 instant 代替 Date,Localdatetime 代替 Calendar, Datetimeformatter 代替 Simpledateformatter,官方给出的解释:simple beautiful strong
immutable thread-safe。
4. 高并发时,同步调用应该去考量锁的性能损耗。能用无锁数据结构,就不要用锁;能 锁区块,就不要锁整个方法体;能用对象锁,就不要用类锁。
5. 对多个资源、数据库表、对象同时加锁时,需要保持一致的加锁顺序,否则可能会造 成死锁。
6. 并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在 数据库层使用乐观锁,使用 version 作为更新依据。
7. 多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获 抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。
8. 线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。
9. 创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。
10. 避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。在 JDK7 之后,可以直接使用 API ThreadLocalRandom,在 JDK7 之前,可以做到每个线 程一个实例。
11. volatile 解决多线程内存不可见问题。对于一写多读,是可以解决变量同步问题, 但是如果多写,同样无法解决线程安全问题。如果想取回 count++数据,使用如下类实现: AtomicInteger count = new AtomicInteger(); count.addAndGet(1); count++操作如果是
JDK8,推荐使用 LongAdder 对象,比 AtomicLong 性能更好(减少乐观锁的重试次数)。
12. ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。 这个变量是针对一个线程内所有操作共有的,所以设置为静态变量,所有此类实例共享此静态 变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象(只要是这 个线程内定义的)都可以操控这个变量。

#### 控制语句
1. 在一个 switch 块内,每个 case 要么通过 break/return 来终止,要么注释说明程序 将继续执行到哪一个 case 为止;在一个 switch 块内,都必须包含一个 default 语句并且放在 最后,即使它什么代码也没有。
2. 在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用下 面的形式:if (condition) statements;
3. 推荐尽量少用 else
4. 循环体中的语句要考量性能,以下操作尽量移至循环体外处理,如定义对象、变量、 获取数据库连接,进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。

#### 注释
1. 类、类属性、类方法的注释必须使用 javadoc 规范,使用/**内容*/格式,不得使用 //xxx 方式。
2. 所有的抽象方法(包括接口中的方法)必须要用 javadoc 注释、除了返回值、参数、
   异常说明外,还必须指出该方法做什么事情,实现什么功能。
3. 所有的类都必须添加创建者信息。
4. 方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使 用/* */注释,注意与代码对齐。
5. 所有的枚举类型字段必须要有注释,说明每个数据项的用途。
6. 代码修改的同时,注释也要进行相应的修改,尤其是参数、返回值、异常、核心逻辑 等的修改。
7. 注释掉的代码尽量要配合说明,而不是简单的注释掉。
8. 对于注释的要求:第一、能够准确反应设计思想和代码逻辑;第二、能够描述业务含 义,使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同 天书,注释是给自己看的,即使隔很长时间,也能清晰理解当时的思路;注释也是给继任者看 的,使其能够快速接替自己的工作。
9. 好的命名、代码结构是自解释的,注释力求精简准确、表达到位。避免出现注释的一 个极端:过多过滥的注释,代码的逻辑一旦修改,修改注释是相当大的负担。

#### 异常
1. 不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类,如: IndexOutOfBoundsException / NullPointerException,这类异常由程序员预检查来规避,保 证程序健壮性。
2. 异常不要用来做流程控制,条件控制,因为异常的处理效率比条件分支低。
3. 对大段代码进行 try-catch,这是不负责任的表现。catch 时请分清稳定代码和非稳 定代码,稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分 异常类型,再做对应的异常处理。
4. 捕获异常是为了处理它,不要捕获了却什么都不处理而抛弃之,如果不想处理它,请 将该异常抛给它的调用者。最外层的业务使用者,必须处理异常,将其转化为用户可以理解的 内容。
5. 有 try 块放到了事务代码中,catch 异常后,如果需要回滚事务,一定要注意手动回 滚事务。
6. finally 块必须对资源对象、流对象进行关闭,有异常也要做 try-catch。 说明:如果 JDK7,可以使用 try-with-resources 方法。
7. 不能在 finally 块中使用 return,finally 块中的 return 返回后方法结束执行,不
会再执行 try 块中的 return 语句。
8. 捕获异常与抛异常,必须是完全匹配,或者捕获异常是抛异常的父类。
9. 方法的返回值可以为 null,不强制返回空集合,或者空对象等,必须添加注释充分 说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。

#### 日志
1. 应用中不可直接使用日志系统(Log4j、Logback)中的 API,而应依赖使用日志框架 SLF4J 中的 API,使用门面模式的日志框架,有利于维护和各个类的日志处理方式统一。
2. 日志文件推荐至少保存 15 天,因为有些异常具备以“周”为频次发生的特点。
3. 对 trace/debug/info 级别的日志输出,必须使用条件输出形式或者使用占位符的方 式。
4. 输出的 POJO 类必须重写 toString 方法,否则只输出此对象的 hashCode 值(地址值),没啥
参考意义。
5. 可以使用 warn 日志级别来记录用户输入参数错误的情况,避免用户投诉时,无所适
从。注意日志输出的级别,error 级别只记录系统逻辑出错、异常、或者重要的错误信息。如 非必要,请不要在此场景打出 error 级别,避免频繁报警。
6. 谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info 日志;如果使 用 warn 来记录刚上线时的业务行为信息,一定要注意日志输出量的问题,避免把服务器磁盘 撑爆,并记得及时删除这些观察日志。

#### mysql
1. 表达是与否概念的字段,必须使用 is_xxx 的方式命名,数据类型是 unsigned tinyint ( 1 表示是,0 表示否)。
2. 表名、字段名必须使用小写字母或数字;禁止出现数字开头,禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大,因为无法进行预发布,所以字段名称需要慎重考虑。
3. 表名不使用复数名词，禁用保留字,如 desc、range、match、delayed 等
4. 小数类型为 decimal,禁止使用 float 和 double。
5. 如果存储的字符串长度几乎相等,使用 CHAR 定长字符串类型。
6. varchar 是可变长字符串,不预先分配存储空间,长度不要超过 5000,如果存储长度 大于此值,定义字段类型为 TEXT,独立出来一张表,用主键来对应,避免影响其它字段索引 效率。
7. 表必备三字段:id, gmt_create, gmt_modified。
8. 单表行数超过 500 万行或者单表容量超过 2GB,才推荐进行分库分表。
9. 合适的字符存储长度,不但节约数据库表空间、节约索引存储,更重要的是提升检索 速度。

#### 索引
1. 业务上具有唯一特性的字段,即使是组合字段,也必须建成唯一索引。不要以为唯一索引影响了 insert 速度,这个速度损耗可以忽略,但提高查找速度是明
显的;另外,即使在应用层做了非常完善的校验和控制,只要没有唯一索引,根据墨菲定律, 必然有脏数据产生。
2. 超过三个表禁止 join。需要 join 的字段,数据类型保持绝对一致;多表关联查询时, 保证被关联的字段需要有索引。
3. 在 varchar 字段上建立索引时,必须指定索引长度,没必要对全字段建立索引,根据 实际文本区分度决定索引长度。
4. 如果有 order by 的场景,请注意利用索引的有序性。order by 最后的字段是组合索 引的一部分,并且放在索引组合顺序的最后,避免出现 file_sort 的情况,影响查询性能。
5. 建组合索引的时候,区分度最高的在最左边。如果 where a=? and b=? ,a 列的几乎接近于唯一值,那么只需要单建 idx_a 索引即可。

#### SQL
1. 不要使用 count(列名)或 count(常量)来替代 count(*),count(*)就是 SQL92 定义的 标准统计行数的语法,跟数据库无关,跟 NULL 和非 NULL 无关。count(*)会统计值为 NULL 的行,而 count(列名)不会统计此列为 NULL 值的行。
2. count(distinct col) 计算该列除 NULL 之外的不重复数量。注意 count(distinct col1, col2) 如果其中一列全为 NULL,那么即使另一列有不同的值,也返回为 0。
3. 当某一列的值全是 NULL 时,count(col)的返回结果为 0,但 sum(col)的返回结果为 NULL,因此使用 sum()时需注意 NPE 问题。可以使用如下方式来避免 sum 的 NPE 问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;
4. 使用 ISNULL()来判断是否为 NULL 值。注意:NULL 与任何值的直接比较都为 NULL。
5. 在代码中写分页查询逻辑时,若 count 为 0 应直接返回,避免执行后面的分页语句。
6. 不得使用外键与级联,一切外键概念必须在应用层解决。
7. 禁止使用存储过程,存储过程难以调试和扩展,更没有移植性
8. in 操作能避免则避免,若实在避免不了,需要仔细评估 in 后边的集合元素数量,控 制在 1000 个之内。

#### 参考
1. 阿里巴巴Java开发手册
2. 华为java编码规范


